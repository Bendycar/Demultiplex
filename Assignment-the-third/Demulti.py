import bioinfo
import argparse
import math
import gzip
import numpy as np
#import matplotlib.pyplot as plt Why on earth is this not working if I'm in my base environment and literally imported plt in pt1...
import itertools

def reverse_complement(DNA: str) -> str:
    '''Simply takes a DNA strand, validates it, and returns the reverse complement if it is a valid DNA string. Case insensitive.'''

    assert bioinfo.validate_base_seq(DNA), "Not a valid DNA sequence"
    complement = {"A" : "T", "T" : "A", "G" : "C", "C" : "G", "a" : "t", "t" : "a", "g" : "c", "c" : "g"}
    RC = ""

    for nucleotide in reversed(DNA):
        RC += complement[nucleotide]
    
    return RC

def average_QScore(phred_score: str) -> float:
    """Takes a string of ASCII + 33 encoded quality scores, returns average value"""
    running_total = 0
    for score in phred_score:
        value = bioinfo.convert_phred(score)
        running_total += value

    return running_total / len(phred_score)

def get_indices(index_location: str) -> set:
    '''Opens a properly formatted indices file at the path given through argparse, creates a set of the indices in this file'''
    
    valid_indices = set()

    with open(index_location, "r") as fh:
        fh.readline() #Gets rid of the first header line
        for line in fh:
            line = line.strip('\n')
            line = line.split('\t')
            index = line[4]
            valid_indices.add(index)
    
    return valid_indices


def get_RC_indices(indices: set) -> dict:
    '''The purpose of this function is to quickly convert the a valid index in R3 to its reverse complement, in order to append to header of matched index reads.
    If the index in R3 is unknown, we will have to manually create its reverse complement. However, this should dramatically speed up generating the RC for known indices.'''
    
    RC_valid_indices = {}

    for index in indices:
        RC_index = reverse_complement(index)
        RC_valid_indices[RC_index] = index #RC is the key because our input will be the RC index in read 3
    
    return RC_valid_indices

def open_files_for_writing(indices: set) -> tuple: #Tuple of two dictionaries, one for R1 and R2
    '''Creates all output files! These are saved for use later in the form of two dictionaries (R1 and R2).
    To write to the files, just call the appropriate dictioanry with either the Index or "Unknown" / "Hopped"'''
    R1_files = {}
    R2_files = {}

    for index in indices:
        R1_files[index] = open(f"R1_{index}.fastq", "w")
        R2_files[index] = open(f"R2_{index}.fastq", "w")
    
    R1_files['Hopped'] = open(f"R1_Hopped.fastq", "w")
    R1_files['Unknown'] = open(f"R1_Unknown.fastq", "w")

    R2_files['Hopped'] = open(f"R2_Hopped.fastq", "w")
    R2_files['Unknown'] = open(f"R2_Unknown.fastq", "w")

    return R1_files, R2_files

def close_all_files(R1_files: dict, R2_files: dict) -> None:
    '''Just call at the end to close all files'''
    for file in R1_files:
        file_handle = R1_files[file]
        file_handle.close()
    
    for file in R2_files:
        file_handle = R2_files[file]
        file_handle.close()

# test_indices = {'ATG', 'TAG'}
# R1_test, R2_test = open_files_for_writing(test_indices)

# R1_test['Hopped'].write('Test')

# close_all_files(R1_test,R2_test)

# R1_test['Hopped'].write('Test2')

def append_indices(Header: str, Index1: str, Index2: str) -> str:
    '''Appends Index 1 and the reverse complement of Index 2 to the header of the given record.
    Returns the modified header'''
    pass

def write_record(record: list, Index: str) -> None:
    '''Writes to the appropriate R1 and R2 files based on the index, which can also be "Hopped" or "Unknown".
    Uses dictionaries generated by open_files_for_writing to find the correct file handles'''
    pass

